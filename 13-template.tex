\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}

% Questo commentalo se vuoi scrivere in inglese.
% \usepackage[italian]{babel}

% \usepackage[italian]{cleveref}
\usepackage{cleveref}

\title{Homer}

\author{Ceccacci Michele, Magnani Simone, Monticelli Alessandro}
\date{\today}


\begin{document}

\maketitle

\begin{abstract}
\end{abstract}

\tableofcontents

\chapter{Analysis}
\section{Requirements}

HOMER (HOMe EmulatoR) is an emulated domotic controller connected to lights, windows, and other domestic facilities.
The smart environment is mananged through a dashboard which allows the user to control devices, monitor sensors and electrical consumptions.
Each device should support updates in variable time units.
Some devices should act in a somewhat random way (but still predictable), while others should be fully deterministic.

\subsubsection{Functional Requirements}

\begin{itemize}
	\item The software should allow creating and controlling lots of different devices, such as:
	\begin{itemize}
		\item Lights
		\item Electrical outlets
		\item Doors, Locks and windows
		\item Temperature changer devices
		\item Air quality sensors
	\end{itemize}
	\item Devices can be added/removed at runtime.
	\item A logger is needed in order to allow users (and possibly machines) to keep track of state changes.
	\item The software should have graph views for temperature and air quality state.
	\item The users should be able to see electrical consumption.
\end{itemize}

\subsubsection{Non-Functional Requirements}

\begin{itemize}
	\item Should performant enough to run on a desktop/laptop.
	\item User interface should be intuitive and user-friendly
	\item The project should be portable, and work on Windows, MacOS and Linux devices.
\end{itemize}

\section{Analysis and domain model}

The application will emulate a domotic environment, some smart devices and facilities monitoring.
Smart devices are common domestic devices as lights, electrical outlets, windows, doors and various sensors 
for monitoring indoor temperature and air quality along with electrical absorption.
The user will interact with the devices via the controller through a dashboard.

The main challenge will be modelling the communication between the controller 
and the different devices, which can have very different states.

\begin{figure}[H]
\centering{}
\includegraphics{img/analysis.pdf}
\caption{Schema UML dell'analisi del problema, con rappresentate le entit√† principali ed i rapporti fra loro}
\label{img:analysis}
\end{figure}

\chapter{Design}
\section{Architecture}

HOMER is built on the MVC (model-view-control) architecture. 
In order to start JavaFX, JFXapplication will be our application's entry point.
JFXApplication will instance the controller, which is responsible for getting inputs from the views,
and updating the model consequently. The controller also sends back state updates to the various views.
The model part is composed by the devices and electrical outlets.


\section{Detailed Design}
Problem: Sending updates from the view to the controller. 
We need a common way for all the UI components to send the same kind of updates to the controller without repeating code.
We also want the controller to have more control over what is actually execute, and when it is executed. So the controller acts as a receiver.
All the commands implement an execute method, that is called inside the controller.
Solution: Used the command pattern

\subsection{Michele Ceccacci}

\textbf{Logger} \newline
Problem: The system needs a composable logger, which has to track both state updates in devices and connections/disconnections
of devices. The need for composition stems from the fact that different use cases of the software might need just a subset
of the logging capabilities. The logger must also be dynamically composable for maximum flexibility.
Solution: used the Decorator design pattern, which allows to wrap dynamically objects at runtime and compose them.
Not using abstract classes also takes away the problems of inheritance. \newline
\includegraphics[width=16cm]{uml/logger.png}

\textbf{Air conditioning and Heating}\newline
Problem: 
Air conditioning and Heating devices have really similar behaviours. The difference between the two, is that an air conditioning
device decreases the environment's temperature, whereas the heating device raises it.
Solution: Since the only function that actually changes between the two implementations is the one responsible for updating the
environment's temperature, the template method pattern was used. 
The method updateTick, responsible to update the environment and electrical consumption when called by the controller,
is a template method, and calls the abstract method updateTemperature. \newline

\includegraphics[width=16cm]{uml/abstractTemperaturechanger.png}

\input{magnani/design.tex}

\chapter{Development}
\section{Automated testing}
We used unit testing especially on the model to prevent regressions, and we tested observable behaviour only.
Our unit test suite uses JUnit.
We decided not to test UI components, since our UI is not the main foucs,
and other areas of the model would benefit more from more granular testing. 
Tested classes:
\begin{itemize}
	\item Temperature
	\item DurationConverter
	\item ElectricalMeter
	\item Lights
	\item Outlets
	\item temperaturechangers
	\item Logger
\end{itemize}

\subsection{Michele Ceccacci}
\begin{itemize}
	\item TemperatureTest
	\item AirqualityStateTest
	\item AbstractTemperatureChangerTest
	\item AirConditioningTest
	\item HeatingTest
	\item LoggerImplTest
\end{itemize}

\input{magnani/testing.tex}

\section{Workflow}
The first step in our process was domain analysis, and then the insights gained were applied by modeling 
the project's main interfaces by using UML.
We used Git as our DCVS. We used gitflow and feature branching, with dev as our development branch,
and main as our stable branch for releases. The workflow is based on pull requests and forks, allowing for asynchronous feedback when needed.
Group meeting were only needed to discuss refactors. 

\subsection{Michele Ceccacci}
\begin{itemize}
	\item Add/remove devices interface.
	\item Actuated devices view
	\item Airconditioning/Heating view and model implementations
	\item Air quality view and model implmentation
	\item Application Logger 
\end{itemize}
\section{Development notes}

\input{magnani/workflow.tex}

\section{Development Notes}

\subsection{Michele Ceccacci}
\begin{itemize}
	\item \textbf{Optional}s were used when the value could either be present or not
	\item \textbf{Streams} were used to access and modify data, especially data that used optional types
	\item \textbf{Records} to make data immutability more explicit, and to avoid reimplementing constructors/HashCode methods
	\item \textbf{Lambda} functions and functional interfaces were used to make code more readable and often complemented streams 
	\item \textbf{JavaFX} was used to develop the main view.
\end{itemize}

\input{magnani/devnotes.tex}

\chapter{Final comments}

\section{Self evaluation and final comments}

\subsection{Michele Ceccacci}
This project definitely improved my teamworking and software architecture skills. 
This was my first time participating in a greenfield project this big, and my first time 
taking architectural decisions that would carry over the whole software's lifecycle. 
In my previous work experience and open source contriubtions, i was more focused on  adding new features 
to an existing project or fixing tickets, rather than actual softare architecture. 
I was familiar proficient at git, but i still made some occasional mistakes.
I think that working in a team without a more senior figure acting as the  lead definitely 
made me more  self reliant, and allowed me to dig deeper into problems.

\input{magnani/selfeval.tex}

\appendix
\chapter{User guide}

In the main tab, there are 3  tabs: devices, scheduler and graphs.
In the devices tab, there is an add window button. After selecting a device,
it will be created (and will be inserted at the bottom). Each device has a remove device button
used to disconnect it, and may have some kind of utility to set its state. \newline
At the bottom there are the scheduler buttons, which allow the user to set scheduler speed, pause it and resume it.
In the scheduler view, the user can select time slices for heating. \newline % TODO this needs to be explained better.
In the graph view, temperature and air quality stats are displayed (provided the user already connected a related sensor).

%TODO: describe outlet view.

\chapter{Lab Assignments}

\input{magnani/lab.tex}

\bibliographystyle{alpha}
\bibliography{13-template}

\end{document}
